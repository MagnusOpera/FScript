---
id: type-provider
title: F# Type Provider and Use Cases
sidebar_label: F# Type Provider
slug: /embedding/type-provider
---

If your host is F#, the FScript type provider gives a strongly-typed bridge from script exports to F# calls.

## What it gives you

The provider can:

- parse and type-check `.fss` scripts at compile time,
- expose `[<export>]` functions as typed static members,
- fail fast when runtime script signatures drift from compile-time expectations.

This is useful when you want dynamic script behavior without giving up compile-time safety in the host codebase.

## Package

- [`MagnusOpera.FScript.TypeProvider`](https://www.nuget.org/packages/MagnusOpera.FScript.TypeProvider)

## Core model

Provider entrypoint namespace/type:

- Namespace: `FScript.TypeProvider`
- Type provider: `FScriptScriptProvider`

Static parameters:

- `ScriptPath` (required)
- `RootDirectory` (optional)
- `ExternProviders` (optional)

## Minimal usage shape (F#)

```fsharp
open FScript.TypeProvider

type BuildScript =
  FScriptScriptProvider<
    ScriptPath = "scripts/build.fss",
    RootDirectory = "."
  >

let result = BuildScript.run "release"
```

`BuildScript.run` above is generated from an `[<export>] let run ...` function in the script.

## Runtime override pattern

For advanced scenarios, the provider supports runtime source overrides via resolver hooks.

- `SetRuntimeResolver`
- `ClearRuntimeResolver`

This lets you switch script source dynamically (for example by tenant/environment) while preserving signature compatibility checks.

## Real-world use cases

## 1) Product rules with safe host calls

Use scripts for business rules (pricing, routing, eligibility), but call them from typed F# methods generated by the provider.

Benefit:

- script flexibility for domain teams,
- compile-time confidence for app developers.

## 2) Plugin-like behavior without reflection-heavy plumbing

Expose plugin functions via `[<export>]` and call them as typed members instead of late-bound string dispatch.

Benefit:

- simpler host code,
- less runtime casting/shape checking logic.

## 3) CI gate for script contract drift

Provider checks script exports at compile time. If script shape changes in a breaking way, the host build fails early.

Benefit:

- breakages are discovered in CI, not in production.

## 4) Environment-specific script resolution

Use runtime resolver override to serve different script sources (dev/staging/prod, tenant-specific variants) while enforcing exported signature compatibility.

Benefit:

- controlled dynamic behavior with a strong compatibility contract.

## When to use provider vs ScriptHost

Use type provider when:

- host is F#,
- you want strongly-typed generated members,
- compile-time validation of script exports is a priority.

Use `ScriptHost` directly when:

- host is not F#,
- you need explicit runtime loading/invocation control,
- you prefer manual dynamic dispatch.
