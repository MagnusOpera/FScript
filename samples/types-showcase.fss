type Address =
    { City: string
      Zip: int }

type OfficeAddress =
    { City: string
      Zip: int }

type User =
    { Id: int
      Name: string
      Tags: string list
      Address: Address option
      Scores: int map
      Pair: (int * string) }

type Subscription =
    | Free
    | Premium of int


let scores =
    { ["math"] = 20; ["science"] = 18 }


let user = { Id = 1; Name = "Ada"; Tags = ["engineer"; "writer"]; Address = Some { City = "London"; Zip = 12345 }; Scores = scores; Pair = (7, "seven") }
let subscription = Premium 12

// Helper typed with OfficeAddress.
let make_office_address (address: OfficeAddress) = address
let officeAddress = make_office_address { City = "London"; Zip = 12345 }
// Same shape as Address, inferred structurally from literal.
let parisAddress = { City = "Paris"; Zip = 75000 }


let updated = { user with Tags = user.Tags @ ["mathematician"] }

// Inline structural annotation: any record with matching fields is accepted.
let format_address (address: { City: string; Zip: int }) = $"{address.City} ({address.Zip})"

// Name exposure for host capability maps.
let capabilities =
    {
        ["format_address"] = "address formatting"
        ["make_office_address"] = "office address constructor"
    }


let city =
    match updated.Address with
    | Some address -> address.City
    | None -> "unknown"


let mathScore =
    updated.Scores
    |> Map.tryGet "math"
    |> Option.defaultValue 0


let hasScience = updated.Scores |> Map.containsKey "science"
let formatAddressKey = "format_address"

let monthlyPrice =
    match subscription with
    | Free -> 0
    | Premium amount -> amount

let missing = "missing"

print $"User: {updated.Name}"
print $"City: {city}"
print $"Math score: {mathScore}"
print $"Has 'science': {hasScience}"
print $"Subscription price: {monthlyPrice}"

// Structural record equivalence showcase:
// - literal with matching fields
// - value created through another named record type (OfficeAddress)
print $"Structural address from literal: {format_address parisAddress}"
print $"Structural address from OfficeAddress: {format_address officeAddress}"
print $"Capability for format_address: {Map.tryGet formatAddressKey capabilities |> Option.defaultValue missing}"


updated.Tags |> List.iter print


match updated with
| { Id = id; Pair = (left, right) } ->
    print $"Record pattern: id={id}, pair=({left}, {right})"
| _ ->
    print "Unexpected"
